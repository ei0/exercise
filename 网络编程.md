# 网络编程
网络基础1/套接字编程/网络基础2/网络基础3/高级IO
## 网络基础1
根据网路覆盖范围划分为：局域网（2km），城域网（20km），广域网
### IP地址-网络中主机的唯一标识
1. IPV4: 
    数据类型-uint32_t 无符号四个字节的整数，不到43亿--存在IP地址不够用
    DHCP 动态地址分配技术-解决IP地址不够问题
    NAT 网络地址转换技术
2. IPV6: 
    数据类型-uint8_t addr[16] 16个字节的整数，但是不兼容IPV4
### 端口PORT-一台主机上唯一标识一个进程
1. 数据类型：uint16_t 无符号两个字节的整数0~65535
2. 特性： 一个端口只能被一个进程占用；
        一个进程可以使用多个端口
3. 熟知端口0~1023保留给常用的服务器应用程序
4. FTP（文件传输协议）服务的默认端口，传输数据端口20，传输控制端口21
- 网络中的每条数据描述都包括：源端口/源IP地址/目的端口/目的IP地址/协议（五元组）
### 协议protocol-网络通信中数据格式约定
协议分层
1. ISO-OSI分层模式：应用层-表示层-会话层-传输层-网络层-链路层-物理层
2. TCP/IP分层模式：应用层-传输层-网络层-链路层-物理层
    2.1 应用层：负责应用程序间的数据沟通；典型协议：HTTP；典型设备：PC
    2.2 传输层：负责应用程序间的数据传输；典型协议：TCP/UDP；典型设备：PC
    2.3 网路层：负责地址管理与路由选择；典型协议：IP；典型设备：路由器
    2.4 链路层：负责相邻设备之间的数据帧传输与识别；典型协议Ethernet-以太网协议；典型设备：交换机
    2.5 物理层：负责光电信号的传输：典型协议：以太网协议；典型设备：集线器
### 数据传输流程-封装与分用的过程
1. 传送：在发送端主机上原始数据会经TCP/IP协议栈五层网络结构模型，层层封装打包发送
2. 接收：接受到打包到的信息，在TCP/IP模型中各层使用各层的可识别信息进行层层分用。
### 网络字节序-大端字节序
- 网络通信中将大端字节序设为标准
1. 字节序：CPU在内存中对数进行存取的顺序
2. 字节序分类
    2.1 大端字节序：低地址存高位
    2.2 小端字节序：低地址存低位
3. 主机字节序由CPU架构决定 X86--小端字节序
    3.1 Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；
    3.2 而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。
4. 判断主机字节序的简单方法
通过共用体实现
`unoin tmp{int a; uchar b;} tmp.a = 1;if(tmp.b == 1){这是小端}`
## 网络编程-socket套接字编程
在网络通信中，总是两台主机（C/S）之间的通信
客户端clinet：主动发出请求；
服务端sever：被动接受请求并给予响应
c/s架构-客户端服务器模式
还有另外的通信模式例如P2P在后面章节会有介绍
程序员可通过套接字对运输层实现控制：
1. 选择运输层协议；
2. 可以设定几个参数，如最大缓存和最大报文段长度等。
### 传输层协议-TCP/UDP
1. TCP：传输控制协议：面向连接，可靠传输，面向字节流
    特性：传输数据的安全性优于实时性--文件传输
2. UDP：用户数据协议：无连接，不可靠，面向数据报
    特性：传输数据的实时性优于安全性--视频传输
### UDP通信流程
1. 创建套接字
在内核中创建一个socket结构体，向用户返回操作句柄
`int socket(int domain,int type,int protocol)`
domain 地址域：地址结构；例如IPV4(AF_INET)、IPV6(AF_INET6)
type 套接字类型：数据报类型(SOCK_DGRAM)、字节流类型(SOCK_STREAM)
protocol协议类型：0为按套接字默认选择
    数据报默认UDP；字节流默认TCP
或者填入TCP协议(IPPROTO_TCP)；UDP协议(IPPROTO_UDP)
返回值：文件描述符
2. 为套接字绑定地址信息
为创建的套接字填充IP地址和端口信息
`int bind(int sockfd,struct sockaddr* addr,socklen_t addrlen);`
sockfd：已创建的套接字返回的操作句柄
addr：地址信息结构体的首地址
addrlen：地址信息长度
返回值成功返回0，失败返回-1；
由于地址信息结构的多样化，一个函数无法处理全部的地址信息结构
为解决此问题，设立地址信息结构化模板`struct sockaddr`
该模板大小为所有地址信息结构中最大的，对于一些较小的地址信息结构会在结构体末尾加入补全位
在所有地址信息结构的头两个字节用来存放地址结构的类型，相当于将各类地址信息结构的名称。
在bind函数内部再根据函数名称进入到相应的地址信息结构处理段
例如：我要定义一个IPV4的地址信息结构
```
struct sockaddr_in tmp;
tmp.sin_family = AF_INET;
tmp.sin_port =···;
tmp.sin_addr = ···;
int ret = bind(sockfd,(struct sockaddr*)tmp,socklen_t len);
```
3. 接收数据
从socket的接收缓冲区中取出网卡接收到的数据
`int recvfrom(int sockfd,char* buf,int buf_len,int flag,struct sockaddr* peer_addr,socklen_t*addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
buf：用户态缓冲区，用于存放从内核中拷贝出来的数据
buf_len：想要获取的数据长度，不能大于buf的长度
flag：默认为0--阻塞接收--接收缓冲区中没有数据的时候阻塞等待
peer_addr：地址缓冲区首地址--用于获取发送这个数据的源端地址--告诉我们这个数据是谁发送的
addr_len：输入输出型参数--用于指定想要多长的地址信息；并用于返回实际获取的地址长度
返回值：成功返回实际接收数据的长度，失败返回-1；
4. 发送数据
将数据放到socket的发送缓冲区
`ssize_t sendto(int sockfd,char* data,int data_len,int flag ,struct sockaddr* dest_addr,socklen_t addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
data：要发送的首地址
data_len：要发送的数据长度
flag：默认为0--阻塞发送数据--发送缓冲区中满的时候阻塞等待
dest_addr：目的端的地址信息首地址--用于告诉socket这个数据发送给谁
addr_len：地址信息长度输入型参数
返回值：成功返回实际发送数据的长度，失败返回-1；
5. 关闭套接字
释放资源
`int close(int fd)`
套接字也称作API-应用程序编程接口
- 字节序转换接口-整数与整数的转化
```
#include<arpa/inet.h>
uint32_t htonl(uint32_t hostlong);  //将4字节的整数转换为网络字节序整数
uint16_t htons(uint16_t hostshort); //将2字节的整数转化为网络字节序整数
uint32_t ntohl(uint32_t netlong);   //将4字节的网络字节序整数转化为主机字节序整数
uint16_t ntohs(uint16_t netshort);  //将2字节的网络字节序整数转化为主机字节序整数
```
- 字节序转换接口-整数与字符串的转化
`int inet_pton(int af,const char* src,void* dst);`---字符串-整数
af：地址域-说明是哪种地址结构
src：字符串的IP地址
dst：转化后的网络字节序整数的IP地址
`in_addr_t inet_addr(char* ip_str)`---将点分2十进制字符串IP地址转换位网络字节序的整数IP地址
`char* inet_ntoa(struct in_addr sin_addr)`---将网络字节序IP地址转换位字符串IP地址，并返回字符串首地址
`const char* inet_ntop(int af,const void* dst,socklen_t size);`---整数-字符串
af：地址域
src：网络字节序的整数IP地址
dst：缓冲区，接受转化后的字符串IP地址
size：缓冲区长度
#### UDP详解
1. 特点：无连接、不可靠传输、面向数据报
 无连接：只需要直到对端地址信息就可以直接发送数据
 不可靠：不保证对方能否收到数据
 面向数据报：有最大长度象值的数据传输方式，sendto中定义数据的最大长度限制
2. udp协议报文格式
 16位：源端端口；16位：目的端端口
 16位：数据报长度（65535）16位：校验和
 数据
 （源端/目的端）端口：标识数据从哪里到哪里
 数据报长度：由两字节的数字标识，故而最大为64K，最小为8字节
 校验和：校验数据的一致性（二进制反码求和算法）；初始值为0，从首字节开始，每个字节进行取反相加，超出16位的部分，进行截取再与低16相加，最终得到的数据填充到校验和中；校验时，将校验和与各个字节进行相加，得到0为数据一致
3. 与上层的联系
应用层发送大文件时（数据大于64K）,不能一次性发送，需要用户在应用层进行分包操作；但并不保证数据的有序到达，因此需要用户在上层进行包序管理
4. 数据的传输
发送方：使用`sendto`函数发送数据，先将数据放到socket的发送缓冲区中，socket会给该数据封装一个头部，然后发送---缓冲区并没有齐到缓冲的作用
接收方：使用`recvfrom`函数接受数据，若是发送了100字节的数据，缓冲区设置小于100字节则会报错，udp的一次通信中，只会交付一条完整的信息。因此缓冲区的设置要足够大
5. 面向数据报
5.1 若在发送大文件时，文件数据大于64K减8（字节），则不能一次性发送，需要用户在应用层进行分包操作；将一个大数据截断为多个小数据进行发送
5.2 udp也不保证数据的有序到达，因此需要用户在应用层进行包序管理
>udp如何实现可靠传输，在应用层将tcp的确认应答机制、超时重传机制、序号确认序号等保证tcp可靠传输的机制实现
### TCP通信流程
#### 接口介绍
1. 创建套接字---srv&cli---
`int socket(int domain,int type,int protocol)`
参数：地址域IPV4--AF_INET,套接字类型字节流传输--SOCK_STREAM,协议类型TCP--IPPROTO_TCP
2. 绑定地址信息---srv&cli---
`int bind(int sockfd,sockaddr* addr,socklen_t len)`
参数：监听套接字操作句柄，地址信息，地址信息长度
3. 开始监听---srv---
`int listen(int sockfd,int backlog)`
参数：监听套接字操作句柄，同一时间客户端连接最大数量
4. 连接请求---cli---
`int connect(int sockfd,struct sockaddr* srvaddr,socklen_t len)`
参数：客户端套接字，服务器端地址信息，信息长度
5. 获取新建连接---srv---阻塞函数
`int accept(int sockfd,struct sockaddr* addr,socklen_t* len_t)`
参数：监听套接字，地址信息，信息长度
返回值：新建套接字句柄
6. 接收数据---srv&cli---flag == 0阻塞函数
`ssize_t recv(int newfd,char* buf,int len,int flag)`
参数：新建套接字句柄，存放接收数据的buf，数据长度，接收类型一般为0--阻塞
返回值，成功返回实际接收数据长度，失败返回-1，连接断开返回0
7. 发送数据---srv&cli---flag == 0阻塞函数
`ssize_t send(int newfd,char* data,int len,int flag)`
参数：新建的接收套接字句柄，存放发送数据的data，数据长度，发送类型一般为0--阻塞
返回值，成功返回实际发送数据长度，失败返回-1，连接断开返回0
8. 关闭套接字---srv&cli---
`int close(fd)`
传入newfd只关闭与某个客户端的通信
传入sockfd关闭监听，不再接受客户端的请求
9. 服务端流程阻塞
9.1 第一种情况：服务端处理完第一个客户端的数据收发之后，循环调用accept，因为没有新的连接到来，流程阻塞，等待新的连接
9.2 第二种情况：服务端接受了第一个客户端连接请求，走到等待接受第一个客户端的数据接受处recv；但是第一个客户端如果不发送数据，则阻塞等待它发送数据
9.3 总结：服务端之所以会被阻塞，是因为程序并不清楚什么时候会有新连接到来也不知道什么时候数据会到来。


#### TCP协议的问题与优化
基本TCP服务器程序存在的问题：srv与cli无法持续通信
1. 主要原因：在一个流程中要完成多种功能，并且每种功能接口都有可能阻塞

>阻塞函数--获取新建连接、收发数据
    
2. 解决方案：采取多执行流方案，每个执行流只负责一个功能---多进程/多线程
3. 多进程：父进程仅获取新建连接，若新建连接创建成功，创建一个子进程来负责后续通讯；
3.1 父子进程代码共享，但数据独有，父进程有新建套接字的操作句柄，但不与客户端进行通信，因此一定要关闭新建套接字
3.2 父进程要注意避免产生僵尸进程，在信号回调函数（SIGCHLD）中进行进程等待(循环)
4. 多线程：主线程获取新连接，创建子线程来完成通讯
4.1 数据不共享，需要在线程入口函数处传入新建套接字，传参时不能直接传递局部变量（循环完毕局部变量会释放），需要在堆上申请一块空间，`TCPSocket* newsock = new TCPSocket()`，直接将描述符的值通过传参传入
4.2 多线程之间资源时共享进程的，意味着这个新建套接字时只有一份的，线程不能随意关闭新建套接字（线程间共享文件描述符表）

5. TCP连接断开后，在两端（cli/srv）的体现：
接收端：recv返回0
发送端，send触发异常--SIGPIPE，导致进程退出（和管道所有读端被关闭继续写时一样的）