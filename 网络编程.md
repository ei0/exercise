# 网络编程
网络基础1/套接字编程/网络基础2/网络基础3/高级IO
## 网络基础1
根据网路覆盖范围划分为：局域网（2km），城域网（20km），广域网
### IP地址-网络中主机的唯一标识
1. IPV4: 
    数据类型-uint32_t 无符号四个字节的整数，不到43亿--存在IP地址不够用
    DHCP 动态地址分配技术-解决IP地址不够问题
    NAT 网络地址转换技术
2. IPV6: 
    数据类型-uint8_t addr[16] 16个字节的整数，但是不兼容IPV4
### 端口PORT-一台主机上唯一标识一个进程
1. 数据类型：uint16_t 无符号两个字节的整数0~65535
2. 特性： 一个端口只能被一个进程占用；
        一个进程可以使用多个端口
3. 熟知端口0~1023保留给常用的服务器应用程序
4. FTP（文件传输协议）服务的默认端口，传输数据端口20，传输控制端口21
- 网络中的每条数据描述都包括：源端口/源IP地址/目的端口/目的IP地址/协议（五元组）
### 协议protocol-网络通信中数据格式约定
协议分层
1. ISO-OSI分层模式：应用层-表示层-会话层-传输层-网络层-链路层-物理层
2. TCP/IP分层模式：应用层-传输层-网络层-链路层-物理层
    2.1 应用层：负责应用程序间的数据沟通；典型协议：HTTP；典型设备：PC
    2.2 传输层：负责应用程序间的数据传输；典型协议：TCP/UDP；典型设备：PC
    2.3 网路层：负责地址管理与路由选择；典型协议：IP；典型设备：路由器
    2.4 链路层：负责相邻设备之间的数据帧传输与识别；典型协议Ethernet-以太网协议；典型设备：交换机
    2.5 物理层：负责光电信号的传输：典型协议：以太网协议；典型设备：集线器
### 数据传输流程-封装与分用的过程
1. 传送：在发送端主机上原始数据会经TCP/IP协议栈五层网络结构模型，层层封装打包发送
2. 接收：接受到打包到的信息，在TCP/IP模型中各层使用各层的可识别信息进行层层分用。
### 网络字节序-大端字节序
- 网络通信中将大端字节序设为标准
1. 字节序：CPU在内存中对数进行存取的顺序
2. 字节序分类
    2.1 大端字节序：低地址存高位
    2.2 小端字节序：低地址存低位
3. 主机字节序由CPU架构决定 X86--小端字节序
    3.1 Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；
    3.2 而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。
4. 判断主机字节序的简单方法
通过共用体实现
`unoin tmp{int a; uchar b;} tmp.a = 1;if(tmp.b == 1){这是小端}`
## 网络编程-socket套接字编程
在网络通信中，总是两台主机（C/S）之间的通信
客户端clinet：主动发出请求；
服务端sever：被动接受请求并给予响应
c/s架构-客户端服务器模式
还有另外的通信模式例如P2P在后面章节会有介绍
程序员可通过套接字对运输层实现控制：
1. 选择运输层协议；
2. 可以设定几个参数，如最大缓存和最大报文段长度等。
### 传输层协议-TCP/UDP
1. TCP：传输控制协议：面向连接，可靠传输，面向字节流
    特性：传输数据的安全性优于实时性--文件传输
2. UDP：用户数据协议：无连接，不可靠，面向数据报
    特性：传输数据的实时性优于安全性--视频传输
### UDP通信流程
1. 创建套接字
在内核中创建一个socket结构体，向用户返回操作句柄
`int socket(int domain,int type,int protocol)`
domain 地址域：地址结构；例如IPV4(AF_INET)、IPV6(AF_INET6)
type 套接字类型：数据报类型(SOCK_DGRAM)、字节流类型(SOCK_STREAM)
protocol协议类型：0为按套接字默认选择
    数据报默认UDP；字节流默认TCP
或者填入TCP协议(IPPROTO_TCP)；UDP协议(IPPROTO_UDP)
返回值：文件描述符
2. 为套接字绑定地址信息
为创建的套接字填充IP地址和端口信息
`int bind(int sockfd,struct sockaddr* addr,socklen_t addrlen);`
sockfd：已创建的套接字返回的操作句柄
addr：地址信息结构体的首地址
addrlen：地址信息长度
返回值成功返回0，失败返回-1；
由于地址信息结构的多样化，一个函数无法处理全部的地址信息结构
为解决此问题，设立地址信息结构化模板`struct sockaddr`
该模板大小为所有地址信息结构中最大的，对于一些较小的地址信息结构会在结构体末尾加入补全位
在所有地址信息结构的头两个字节用来存放地址结构的类型，相当于将各类地址信息结构的名称。
在bind函数内部再根据函数名称进入到相应的地址信息结构处理段
例如：我要定义一个IPV4的地址信息结构
```
struct sockaddr_in tmp;
tmp.sin_family = AF_INET;
tmp.sin_port =···;
tmp.sin_addr = ···;
int ret = bind(sockfd,(struct sockaddr*)tmp,socklen_t len);
```
3. 接收数据
从socket的接收缓冲区中取出网卡接收到的数据
`int recvfrom(int sockfd,char* buf,int buf_len,int flag,struct sockaddr* peer_addr,socklen_t*addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
buf：用户态缓冲区，用于存放从内核中拷贝出来的数据
buf_len：想要获取的数据长度，不能大于buf的长度
flag：默认为0--阻塞接收--接收缓冲区中没有数据的时候阻塞等待
peer_addr：地址缓冲区首地址--用于获取发送这个数据的源端地址--告诉我们这个数据是谁发送的
addr_len：输入输出型参数--用于指定想要多长的地址信息；并用于返回实际获取的地址长度
返回值：成功返回实际接收数据的长度，失败返回-1；
4. 发送数据
将数据放到socket的发送缓冲区
`ssize_t sendto(int sockfd,char* data,int data_len,int flag ,struct sockaddr* dest_addr,socklen_t addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
data：要发送的首地址
data_len：要发送的数据长度
flag：默认为0--阻塞发送数据--发送缓冲区中满的时候阻塞等待
dest_addr：目的端的地址信息首地址--用于告诉socket这个数据发送给谁
addr_len：地址信息长度输入型参数
返回值：成功返回实际发送数据的长度，失败返回-1；
5. 关闭套接字
释放资源
`int close(int fd)`
套接字也称作API-应用程序编程接口
- 字节序转换接口-整数与整数的转化
```
#include<arpa/inet.h>
uint32_t htonl(uint32_t hostlong);  //将4字节的整数转换为网络字节序整数
uint16_t htons(uint16_t hostshort); //将2字节的整数转化为网络字节序整数
uint32_t ntohl(uint32_t netlong);   //将4字节的网络字节序整数转化为主机字节序整数
uint16_t ntohs(uint16_t netshort);  //将2字节的网络字节序整数转化为主机字节序整数
```
- 字节序转换接口-整数与字符串的转化
`int inet_pton(int af,const char* src,void* dst);`---字符串-整数
af：地址域-说明是哪种地址结构
src：字符串的IP地址
dst：转化后的网络字节序整数的IP地址
`in_addr_t inet_addr(char* ip_str)`---将点分2十进制字符串IP地址转换位网络字节序的整数IP地址
`char* inet_ntoa(struct in_addr sin_addr)`---将网络字节序IP地址转换位字符串IP地址，并返回字符串首地址
`const char* inet_ntop(int af,const void* dst,socklen_t size);`---整数-字符串
af：地址域
src：网络字节序的整数IP地址
dst：缓冲区，接受转化后的字符串IP地址
size：缓冲区长度
#### UDP详解
1. 特点：无连接、不可靠传输、面向数据报
 无连接：只需要直到对端地址信息就可以直接发送数据
 不可靠：不保证对方能否收到数据
 面向数据报：有最大长度象值的数据传输方式，sendto中定义数据的最大长度限制
2. udp协议报文格式
 16位：源端端口；16位：目的端端口
 16位：数据报长度（65535）16位：校验和
 数据
 （源端/目的端）端口：标识数据从哪里到哪里
 数据报长度：由两字节的数字标识，故而最大为64K，最小为8字节
 校验和：校验数据的一致性（二进制反码求和算法）；初始值为0，从首字节开始，每个字节进行取反相加，超出16位的部分，进行截取再与低16相加，最终得到的数据填充到校验和中；校验时，将校验和与各个字节进行相加，得到0为数据一致
3. 与上层的联系
应用层发送大文件时（数据大于64K）,不能一次性发送，需要用户在应用层进行分包操作；但并不保证数据的有序到达，因此需要用户在上层进行包序管理
4. 数据的传输
发送方：使用`sendto`函数发送数据，先将数据放到socket的发送缓冲区中，socket会给该数据封装一个头部，然后发送---缓冲区并没有齐到缓冲的作用
接收方：使用`recvfrom`函数接受数据，若是发送了100字节的数据，缓冲区设置小于100字节则会报错，udp的一次通信中，只会交付一条完整的信息。因此缓冲区的设置要足够大
5. 面向数据报
5.1 若在发送大文件时，文件数据大于64K减8（字节），则不能一次性发送，需要用户在应用层进行分包操作；将一个大数据截断为多个小数据进行发送
5.2 udp也不保证数据的有序到达，因此需要用户在应用层进行包序管理
>udp如何实现可靠传输，在应用层将tcp的确认应答机制、超时重传机制、序号确认序号等保证tcp可靠传输的机制实现
### TCP通信流程
#### 接口介绍
1. 创建套接字---srv&cli---
`int socket(int domain,int type,int protocol)`
参数：地址域IPV4--AF_INET,套接字类型字节流传输--SOCK_STREAM,协议类型TCP--IPPROTO_TCP
2. 绑定地址信息---srv&cli---
`int bind(int sockfd,sockaddr* addr,socklen_t len)`
参数：监听套接字操作句柄，地址信息，地址信息长度
3. 开始监听---srv---
`int listen(int sockfd,int backlog)`
参数：监听套接字操作句柄，同一时间客户端连接最大数量
4. 连接请求---cli---
`int connect(int sockfd,struct sockaddr* srvaddr,socklen_t len)`
参数：客户端套接字，服务器端地址信息，信息长度
5. 获取新建连接---srv---阻塞函数
`int accept(int sockfd,struct sockaddr* addr,socklen_t* len_t)`
参数：监听套接字，地址信息，信息长度
返回值：新建套接字句柄
6. 接收数据---srv&cli---flag == 0阻塞函数
`ssize_t recv(int newfd,char* buf,int len,int flag)`
参数：新建套接字句柄，存放接收数据的buf，数据长度，接收类型一般为0--阻塞
返回值，成功返回实际接收数据长度，失败返回-1，连接断开返回0
7. 发送数据---srv&cli---flag == 0阻塞函数
`ssize_t send(int newfd,char* data,int len,int flag)`
参数：新建的接收套接字句柄，存放发送数据的data，数据长度，发送类型一般为0--阻塞
返回值，成功返回实际发送数据长度，失败返回-1，连接断开返回0
8. 关闭套接字---srv&cli---
`int close(fd)`
传入newfd只关闭与某个客户端的通信
传入sockfd关闭监听，不再接受客户端的请求
9. 服务端流程阻塞
9.1 第一种情况：服务端处理完第一个客户端的数据收发之后，循环调用accept，因为没有新的连接到来，流程阻塞，等待新的连接
9.2 第二种情况：服务端接受了第一个客户端连接请求，走到等待接受第一个客户端的数据接受处recv；但是第一个客户端如果不发送数据，则阻塞等待它发送数据
9.3 总结：服务端之所以会被阻塞，是因为程序并不清楚什么时候会有新连接到来也不知道什么时候数据会到来。


#### TCP协议的问题与优化
基本TCP服务器程序存在的问题：srv与cli无法持续通信
1. 主要原因：在一个流程中要完成多种功能，并且每种功能接口都有可能阻塞

>阻塞函数--获取新建连接、收发数据
    
2. 解决方案：采取多执行流方案，每个执行流只负责一个功能---多进程/多线程
3. 多进程：父进程仅获取新建连接，若新建连接创建成功，创建一个子进程来负责后续通讯；
3.1 父子进程代码共享，但数据独有，父进程有新建套接字的操作句柄，但不与客户端进行通信，因此一定要关闭新建套接字
3.2 父进程要注意避免产生僵尸进程，在信号回调函数（SIGCHLD）中进行进程等待(循环)
4. 多线程：主线程获取新连接，创建子线程来完成通讯
4.1 数据不共享，需要在线程入口函数处传入新建套接字，传参时不能直接传递局部变量（循环完毕局部变量会释放），需要在堆上申请一块空间，`TCPSocket* newsock = new TCPSocket()`，直接将描述符的值通过传参传入
4.2 多线程之间资源时共享进程的，意味着这个新建套接字时只有一份的，线程不能随意关闭新建套接字（线程间共享文件描述符表）

5. TCP连接断开后，在两端（cli/srv）的体现：
接收端：recv返回0
发送端，send触发异常--SIGPIPE，导致进程退出（和管道所有读端被关闭继续写时一样的）
#### TCP详解
1. 特点：面向连接、可靠传输、面向字节流
面向连接：通过三次握手建立连接/四次挥手挥手断开连接以及状态的连接管理实现面向连接---tcp协议是一个有状态的协议
可靠传输：保证数据有序并可到达对端
面向字节流：可靠的、有序的、全双工、基于连接的字节流传输
2. tcp协议报文格式
16位源端端口；16位目的端端口；32为序号；32位确认序号；
4位头部长度；6位保留位；6位标志位；16位窗口大小
16位校验和；16位紧急指针；40字节选项数据；数据
（源端/目的端）端口：负责数据传输的地址
序号/确认序号：实现tcp在传输层的包序管理--tcp有序交付数据
头部长度：计数单位为4字节，4位共可表示60字节
标志位：URG-紧急指针标志/ACK-确认回复标志/PSH-提示立即接受/RST-重置连接/SYN-连接建立请求/FIN-断开连接请求
窗口大小：滑动窗口机制--流量控制--告诉对端所能发送的最大数据量
紧急指针：指明哪些数据是紧急数据
校验和：二进制反码求和校验数据一致性
选项数据：三次握手时，协商MSS大小的数据
3. tcp连接管理
双方建立套接字、绑定地址信息
三次握手开始
服：状态-LISTEN（获取客户端的连接请求）
客：状态-SYN_SENT（发送连接请求）操作-发送SYN（连接请求）
服：状态-SYN_RCVD（确认连接请求并等待对方回复）操作-发送ACK+SYN
客：状态-ESTABLISHED（连接成功，可通信）操作-发送ACK
服：状态-ESTABLISHED（连接成功，可通行）
三次握手结束
···
···
四次挥手开始
客：调用shutdown(fd,SHUT_WR)---关闭客户端写功能
客：状态-FIN_WAIT1（不再向对方发送数据）操作-发送FIN
服：状态-CLOSE_WAIT(服务端不再读，recv不阻塞且返回0)
服：调用shutdown(fd,SHUT_RD)---关闭服务端读功能
服：状态-CLOSE_WAIT(服务端不再读，recv不阻塞且返回0) 操作-发送ACK
客：状态-FIN_WAIT2(等待服务端的最后一个FIN)
服：调用shutdown(fd,SHUT_WR)---关闭服务端写功能
服：状态-LAST_ACK（服务端也不再写）操作-发送FIN
客：状态-FIN_WAIT2(等到最后一个FIN) 操作-发送ACK
服：状态-CLOSE（等一会后服务端资源释放）
客：等待一段时间后进入CLOSE（客户端资源释放）
四次挥手结束
- shutdown/close/FIN
`shutdown(fd,how)`---只关闭功能，不释放套接字资源
fd：被操作的套接字
how：SHUT_WR/SHUT_RD/SHUT_RDWR
`close(fd)`--关闭套接字读写功能，释放资源
FIN包--只要关闭写端就会发送FIN包，并非表示断开连接
- 握手建立连接为什么是三次
两次不安全，四次没必要
tcp是双向通信，需要双方都确保对方在线，具有数据收发的能力
两次连接
客：发送SYN包
服：回复ACK
只保证了客户端具有发送的能力，并不确保它具有接受数据的能力
四次连接没有必要，在第一次回答时ACK与SYN结合
- 挥手断开连接为什么是四次
第一次挥手    
因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。 
第二次挥手    
被动方*此时有可能还有相应的数据报文需要发送*，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）
第三次挥手   
被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。  
第四挥手   
如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态
- 客户端为什么还要有个TIME_WAIT状态
若主动方发送最后一个ACK后，被动方若没有接受到，则会超时重发第二个FIN包，导致后续连接出错
出错的两个点，主动方刚重启时接受到一个FIN包；主动方向被动方发送SYN而被动方处在LAST_ACK，收到SYN会向主动方发送RST重置连接报文
等待的时间长度为两个MSL（报文最大生存周期），重传FIN包和响应ACK两个报文，目的在于要求本次来连接的所有数据都消失，不对后续操作造成影响
- 若三次握手失败，服务端如何处理
第一种情况
客户端的SYN没到达服务端，不做任何处理
第二种情况
服务端没收到第二个ACK，则发送RST重置连接，释放当前套接字，新建套接字重新发送ACK+SYN
- 服务器上出现大量的CLOSE_WAIT是什么原因
CLOSE_WAIT收到主动方的FIN包后等待程序调用close/shutdown(fd,SHUT_WR)
程序作为被动方时，在连接断开后，没有调用close关闭，释放资源
解决方法：检查代码
- 服务器上出现大量的TIME_WAIT是什么原因
TIME_WAIT 主动方，发送最后一个ACK后的状态
意味着服务器上大量主动的关闭了连接-通常出现在爬虫服务器上
解决方法：开启tcp连接重用、设置MSL时间
- TCP服务器最大并发连接数是多少
他可以同时连接的客户端数量并不受限于可用端口号，理论上一个服务器的一个端口能建立的连接数是全球的IP数*每台机器���端口数。
实际并发连接数受限于linux可打开文件数
通过`#ulimit -n `查看服务的最大文件句柄数，通过`ulimit -n xxx `修改 xxx是你想要能打开的数量
- 四种情况会发送RST包：
&emsp;1、端口未打开
&emsp;2、请求超时
&emsp;3、提前关闭
&emsp;4、在一个已关闭的socket上收到数据i7t
4. 可靠传输
实现可靠传输的技术：连接管理、确认应答机制、超时重传机制、议中校验和字段、协议中序号和确认序号字段
4.1 连接管理
&emsp;概述：通过来连接管理保证双方都具有数据收发的能力---三次握手四次挥手
4.2 确认应答机制
&emsp;概述：接收方对于接收到的每一条数据都要进行确认回复，告诉发送方说数  据我收到了--使用确认序号进行应答
&emsp;实现：通过seq和ack来确保数据的完整达到，seq当前数据的起始序号，ack确认序号确认**该序号之前**的数据都已完整达到
4.3 超时重传机制
&emsp;概述：发送方发送数据后一段时间内没有收到确认回复，则对数据进行重传
&emsp;等待时间：动态的随着网络变化；一开始等待很短的时间就会重传，但若多条数据都在短时间内无法得到响应，则会调整等待时间。
4.4 校验和字段：校验数据一致性，不一致则要重传
4.5 序号和确认序号字段：进行包序管理，保证数据有序交付
4.6 滑动窗口机制--避免丢包
概述：实现发送方连续发送多条数据，并且进行流量控制--使用协议中的窗口大小来实现
在三次握手时，双方会通过选项数据来协商MSS（最大数据段大小）的大小--MSS一次发送的最大数据
客户端MSS和服务端MSS的最小值为传输MSS，WIN窗口大小接收方的接收缓冲区剩余空间决定，每次传输WIN都会改变。
窗口两沿的移动：
&emsp;发送方后沿移动：收到接收方的确认回复，再移动一个传输大小（最大为MSS）
&emsp;发送方前沿移动：前沿-后沿 == WIN 当后沿移动时，前沿参考WIN大小移动
&emsp;接收方后沿移动：移动多少取决于接收到数据大小
&emsp;接收方前沿移动：取决于剩余空间的大小，用户随时会将recv中的数据取出去
4.7 快速重传机制--丢包处理
基于滑动窗口实现数据连续发送
概述：若没收到第一条数据，而收到第二条数据，则接收方认为第一条数据丢失，因此就会每隔一会发送第一条数据的重传请求，连续发送三次。
连续发送三次：为防止数据延迟的情况。数据并非丢失而是由于IP层的乱序使得他后于第二条数据到达
数据重发相关协议：
停等协议：收到回复才会发送下一条数据--针对网络状况不好的情况
选择重传协议：哪条丢失重传那条
回退n步协议：从丢失的那条开始后边的数据都重传
4.8 拥塞窗口--避免丢包
滑动窗口机制实现了数据的连续大量发送；但若在通信时，不了解双方网络状况，直接发送大量数据，会造成大量丢包。
因此发送方总是维护一个拥塞窗口进行拥塞控制，实现网络探测，避免因为网络不好造成的大量丢包
由小数据开始发送，探测网络通信的通信质量，数据以指数形式增长，最大为滑动窗口大小。丢包会重新探测
4.9 延时应答机制
接收方接收一条数据后并不进行立即回复，使得窗口变小，数据吞吐率降低；延迟一会再应答，这个延迟期间若数据被取出去，则不用改变窗口大小，维持较高的吞吐率。
4.10 捎带应答机制
每一条确认回复都是一条数据，至少需要一个tcp报头，因此将确认回复与即将发送的数据合成一个数据发送，减少不必要数据的发送。
4.11 总结
可靠传输：
保证：面向连接、确认应答、超时重传、确认序号、校验和
丢包：滑动窗口（流量控制）、拥塞窗口
性能：延时应答、捎带应答
5. 面向字节流
字节流传输：发送的数据都会放到发送缓冲区进行缓冲，根据自己的实际情况从缓冲区中取出合适大小的数据进行封装发送。
特点：传输比较灵活，并不限制上层发送的数据大小与接收数据大小
弊端：粘包-多条数据粘在一起，被tcp作为一条数据发送给上层，发生在接收端/发送端
本质原因：tcp对于上层数据的边界不敏感
解决：程序员在应用层进行边界管理
&emsp;使用特殊字符作为间隔（http协议）
&emsp;设定定长的数据--容易造成资源浪费
&emsp;应用层头部定义数据长度（udp协议）
故而udp协议不会产生粘包
### 应用层协议
>应用层协议为程序员自定义的协议--私有协议

1. 如何自定义一个协议：协议就是数据格式的约定---数据格式该如何排布/如何解析

2. 序列化：将数据对象按照指定的协议格式进行持久化存储（数据传输）的过程

3. 反序列化：将持久化存储（二进制--反序列化更快）数据串按照指定协议解析出各个数据对象的过程

ep: 网络版计算器：客户端要将计算的两个数字以及运算符发送给服务端，由服务端进行计算并返回结果
传输方式：
    a. 将数据对象以特殊字符进行间隔组织为字符串进行传输
    b. 结构化数据传输--用户感受不到数据对象按照指定协议组织以及解析的过程且通过结构成员变量指向内存各处的方式，可以更快的获取到数据对象，反序列化更快。

json序列化/protobuf序列化

4. 自定义协议
如何定制一个应用层协议：结构化数据传输
序列化与反序列的知识
序列化的方式有哪些以及优缺点
#### HTTP协议详解
>HTTP协议：超文本传输协议 ，默认端口80
>HTML：超文本标记语言-给程序员一定的自制空间

1. 网址：统一资源定位符--URL--在网络中唯一定位一个服务器上的某个资源
组成：http://username:password@ip:port/path?key=val&key=val#ch
协议方案名称://用户:密码@srv-IP地址:srv-端口号/资源路径?查询字符串&查询字符串#html标签
2. 协议格式
2.1 首行：请求第一行/响应第一行；三条信息（请求方法 URL 协议版本），用空格隔开，以`\r\n`结尾
请求方法：GET-主要用于获取资源/HEAD-相较于GET只要头部不要正文/POST-主要用于向服务器提交表单数据
GET主要用于获取实体资源，请求没有正文，若要提交数据，需要将数据作为查询字符串放到URL中，缺点：url是很容易获得的明文信息，且最大长度限制在1~8k。
POST主要用于向服务器提交数据，并且数据存放于正文中
HTTP1.0，三种：post，get，head
HTTP1.1，八种：post，get，head，options，put，delete，trace，connect
HTTP版本
HTTP/0.9：短连接--在传输层使用tcp来连接，得到响应则通信结束关闭连接，只支持GET
HTTP/1.0：支持长连接-并新增HEAD/POST
HTTP/1.1：在支持长连接的基础上支持管线化传输；并新增更多的请求方法以及头部信息
HTTP/2：新增了更多的特性，新增服务器主动向客户端推送消息

2.2 头部：描述本次请求/响应的关键信息；由许多个key-val形式的键值对组成，每个键值对以`\r\n`结束
`Connection:keep-alive/close`本次请求是长连接/是短连接
`Content-Type`用于描述正文的数据类型
`User-Agent`客户端描述信息
`Accept`告诉对方我能接受什么样的数据
`Referer`客户端告诉服务端我是从哪跳转过来的
`Transfer-Encoding`传输编码--chunked分块传输--正文不会一次全部传输，每次传输一块并传输该块的长度
`Location`-搭配3xx状态码使用，告诉对方资源重定向的新位置
在头部最后一个键值对描述结束后，再加入一个`\r\n`标识整个头部的结束
- 标准的响应头部和请求头部
3. Cookie/Set-Cookie
基于早期的短连接，每次完成请求/响应后都会断开，对某些多连接/请求操作过于繁琐
解决方案：Cookie
客户端登陆一次，服务端为客户端创建一个session（会话），会话中保存当前会话信息，客户端的认证信息，存储到数据库中，再登陆成功响应是使用Set-Cookie告诉对方会话id是多少；客户端收到这个响应后，将Cookie中的信息保存起来，下一次客户端访问服务器的时候，就会自动将保存的Cookie信息读取并发送到服务端，服务端取到Session_id，通过该id在数据库中寻找会话信息
Cookie与Session
Cookie：保存在客户端浏览器中，Cookie只能存储字符串
Cookie有效期，若没设置expires则退出当前会话后失效
Cookie的基础属性
&emsp;domain:可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。
&emsp;path:Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。
&emsp;httponly:如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性,但不是绝对防止了攻击
&emsp;secure:该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。
&emsp;expires:指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期
Session：保存在服务端，可存储各种类型数据
Session有效期默认为30min
4. 简单HTTP服务器的实现
4.1 搭建一个TCP服务器，用来连接
4.2 连接成功后，收发数据（http协议格式的数据-首行、头部、正文）
4.3 解析请求
4.4 根据需求进行处理，并响应
5. HTTPS
默认端口为443
## 网络基础3--网络层
### 网络层-负责地址管理与路由选择（IP）
#### IP协议格式
1. 报文格式
4位协议版本；IPV4/IPV6；
4位首部长度：记录IP报头长度，IP报文中也有40字节的选项数据（4字节位为单位）
8位TOS字段：3位优先权字段（弃用）、4位服务类型：最小延迟，大吞吐量，高可靠性，小成本、1位保留
16位头部长度：IP报文长度（包含头部）--最大64k
16位分片标识：
2. 报文特点
IP报文最小为20字节
#### 网络层功能的实现：地址管理与路由选择
1. 地址管理
IP地址组成：网络号+主机号
网络号：标识一个网络
主机号：在局域网中标识主机 
1.1 网段的划分
A类：高1位固定，7位网络号，24位主机号--用于组建超大型网络--可包含一千多万主机0.0.0.0~127.255.255.255
B类：高2位固定
C类：高3位固定
D类：高4位固定
E类：高5位固定
## 经典IO
### 阻塞IO
### 非阻塞IO
### 异步IO
异步阻塞和异步非阻塞：进程发起调用之后，功能由操作系统来完成，若进程一直等着则是阻塞，进程不等待而是继续运行，是非阻塞
### 信号驱动IO
### 多路转接IO
对于大量的IO就绪事件进行监控，实现让进程仅针对已经就绪的IO进行操作，提高IO效率，避免流程阻塞
描述符的可读事件：接收缓冲区的数据大小大于低水位标记（默认1字节）
描述符的可写事件：发送缓冲区中的剩余空间大小大于低水位标记（默认1字节）
#### select
1. 流程
1.1 定义指定事件的描述符集合：可读事件、可写事件、异常事件`FD_ZROE(fd_set * a)//q清空集合`
1.2 将描述符添加到自己指定的集合（可读、可写、异常）`FD_SET(int fd,fd_set * a)`
1.3 开始监控，将集合拷贝到内核中，遍历监控
`int select(int nfds,fd_set*r,*w,*e,struct timeval timeout);//timeout == NULL阻塞 == 0非阻塞，tv_sec/tv_usec阻塞时长`
1.4 返回已就绪的描述符，未就绪的被删除，重新监控则需要重新添加描述符
1.5 判断描述符是否还在集合中`int FD_ISSET(intfd,fd_set*a)`
1.6 移除某个描述符`void FD_CLR(int fd,fd_set* a)`
select的封装
```
class Select{
    int _maxfd;
    fd_set _rfds;
public:
    bool Add(const TcpSocket &sock);//添加描述符
    bool Del(const TcpSocket &sock);//删除描述符
    bool Wait(std::vector<TcpSocket> *list);//开始监控
}
```
2. 缺点分析：
2.1 所能监控的描述符有最大上限宏`__FD_SETSIZE`，默认为1024个
2.2 在内核中轮询遍历，若描述符过多性能下降
2.3 只返回的就绪描述符集合并不详细告诉用户哪个就绪，需要再次遍历
2.4 每次返回后，会删除未就绪描述符，则需要重新添加描述符
3. 优点分析
3.1 对于阻塞时间的设定可精确到微妙
3.2 遵循posix标准跨平台移植性好
#### poll
将select的三个描述符集合，结合描述符，构成一个新的结构体，别的流程都一致
解决了监控的描述符数量问题
#### epoll
红黑树、回调函数、双向链表（rdlist）
监控流程：
1. 在内核中创建epoll句柄
2. 向内核添加监控的描述符以及对应事件节点 struct epoll_event
3. 开始监控，给用户直接返回就绪的事件节点（异步阻塞操作：监控在内核，进程只判断是否就绪）
4. 用户直接对就绪的事件进行操作
高性能的原因:
1. epoll的监控只需要判断双向链表是否为空就可以完成判断，不需要遍历，因此性能不会随着描述符的增多而下降；
2. epoll的事件节点只需要向内核添加一次
3. epool向用户返回就绪节点采用内存映射，避免了数据的拷贝过程

## 链路层
### ARP协议
