# 网络编程
网络基础1/套接字编程/网络基础2/网络基础3/高级IO
## 网络基础1
根据网路覆盖范围划分为：局域网（2km），城域网（20km），广域网
### IP地址-网络中主机的唯一标识
1. IPV4: 
    数据类型-uint32_t 无符号四个字节的整数，不到43亿--存在IP地址不够用
    DHCP 动态地址分配技术-解决IP地址不够问题
    NAT 网络地址转换技术
2. IPV6: 
    数据类型-uint8_t addr[16] 16个字节的整数，但是不兼容IPV4
### 端口PORT-一台主机上唯一标识一个进程
1. 数据类型：uint16_t 无符号两个字节的整数0~65535
2. 特性： 一个端口只能被一个进程占用；
        一个进程可以使用多个端口
3. 熟知端口0~1023保留给常用的服务器应用程序
4. FTP（文件传输协议）服务的默认端口，传输数据端口20，传输控制端口21
- 网络中的每条数据描述都包括：源端口/源IP地址/目的端口/目的IP地址/协议（五元组）
### 协议protocol-网络通信中数据格式约定
协议分层
1. ISO-OSI分层模式：应用层-表示层-会话层-传输层-网络层-链路层-物理层
2. TCP/IP分层模式：应用层-传输层-网络层-链路层-物理层
    2.1 应用层：负责应用程序间的数据沟通；典型协议：HTTP；典型设备：PC
    2.2 传输层：负责应用程序间的数据传输；典型协议：TCP/UDP；典型设备：PC
    2.3 网路层：负责地址管理与路由选择；典型协议：IP；典型设备：路由器
    2.4 链路层：负责相邻设备之间的数据帧传输与识别；典型协议Ethernet-以太网协议；典型设备：交换机
    2.5 物理层：负责光电信号的传输：典型协议：以太网协议；典型设备：集线器
### 数据传输流程-封装与分用的过程
1. 传送：在发送端主机上原始数据会经TCP/IP协议栈五层网络结构模型，层层封装打包发送
2. 接收：接受到打包到的信息，在TCP/IP模型中各层使用各层的可识别信息进行层层分用。
### 网络字节序-大端字节序
- 网络通信中将大端字节序设为标准
1. 字节序：CPU在内存中对数进行存取的顺序
2. 字节序分类
    2.1 大端字节序：低地址存高位
    2.2 小端字节序：低地址存低位
3. 主机字节序由CPU架构决定 X86--小端字节序
    3.1 Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；
    3.2 而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。
4. 判断主机字节序的简单方法
通过共用体实现
`unoin tmp{int a; uchar b;} tmp.a = 1;if(tmp.b == 1){这是小端}`
## 网络编程-socket套接字编程
在网络通信中，总是两台主机（C/S）之间的通信
客户端clinet：主动发出请求；
服务端sever：被动接受请求并给予响应
c/s架构-客户端服务器模式
还有另外的通信模式例如P2P在后面章节会有介绍
程序员可通过套接字对运输层实现控制：
1. 选择运输层协议；
2. 可以设定几个参数，如最大缓存和最大报文段长度等。
### 传输层协议-TCP/UDP
1. TCP：传输控制协议：面向连接，可靠传输，面向字节流
    特性：传输数据的安全性优于实时性--文件传输
2. UDP：用户数据协议：无连接，不可靠，面向数据报
    特性：传输数据的实时性优于安全性--视频传输
### UDP通信流程
1. 创建套接字
在内核中创建一个socket结构体，向用户返回操作句柄
`int socket(int domain,int type,int protocol)`
domain 地址域：地址结构；例如IPV4(AF_INET)、IPV6(AF_INET6)
type 套接字类型：数据报类型(SOCK_DGRAM)、字节流类型(SOCK_STREAM)
protocol协议类型：0为按套接字默认选择
    数据报默认UDP；字节流默认TCP
或者填入TCP协议(IPPROTO_TCP)；UDP协议(IPPROTO_UDP)
返回值：文件描述符
2. 为套接字绑定地址信息
为创建的套接字填充IP地址和端口信息
`int bind(int sockfd,struct sockaddr* addr,socklen_t addrlen);`
sockfd：已创建的套接字返回的操作句柄
addr：地址信息结构体的首地址
addrlen：地址信息长度
返回值成功返回0，失败返回-1；
由于地址信息结构的多样化，一个函数无法处理全部的地址信息结构
为解决此问题，设立地址信息结构化模板`struct sockaddr`
该模板大小为所有地址信息结构中最大的，对于一些较小的地址信息结构会在结构体末尾加入补全位
在所有地址信息结构的头两个字节用来存放地址结构的类型，相当于将各类地址信息结构的名称。
在bind函数内部再根据函数名称进入到相应的地址信息结构处理段
例如：我要定义一个IPV4的地址信息结构
```
struct sockaddr_in tmp;
tmp.sin_family = AF_INET;
tmp.sin_port =···;
tmp.sin_addr = ···;
int ret = bind(sockfd,(struct sockaddr*)tmp,socklen_t len);
```
3. 接收数据
从socket的接收缓冲区中取出网卡接收到的数据
`int recvfrom(int sockfd,char* buf,int buf_len,int flag,struct sockaddr* peer_addr,socklen_t*addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
buf：用户态缓冲区，用于存放从内核中拷贝出来的数据
buf_len：想要获取的数据长度，不能大于buf的长度
flag：默认为0--阻塞接收--接收缓冲区中没有数据的时候阻塞等待
peer_addr：地址缓冲区首地址--用于获取发送这个数据的源端地址--告诉我们这个数据是谁发送的
addr_len：输入输出型参数--用于指定想要多长的地址信息；并用于返回实际获取的地址长度
返回值：成功返回实际接收数据的长度，失败返回-1；
4. 发送数据
将数据放到socket的发送缓冲区
`ssize_t sendto(int sockfd,char* data,int data_len,int flag ,struct sockaddr* dest_addr,socklen_t addr_len);`
sockfd:指定内核中的socket结构体--从哪个socket的缓冲区中取出数据
data：要发送的首地址
data_len：要发送的数据长度
flag：默认为0--阻塞发送数据--发送缓冲区中满的时候阻塞等待
dest_addr：目的端的地址信息首地址--用于告诉socket这个数据发送给谁
addr_len：地址信息长度输入型参数
返回值：成功返回实际发送数据的长度，失败返回-1；
5. 关闭套接字
释放资源
`int close(int fd)`
套接字也称作API-应用程序编程接口
- 字节序转换接口-整数与整数的转化
```
#include<arpa/inet.h>
uint32_t htonl(uint32_t hostlong);  //将4字节的整数转换为网络字节序整数
uint16_t htons(uint16_t hostshort); //将2字节的整数转化为网络字节序整数
uint32_t ntohl(uint32_t netlong);   //将4字节的网络字节序整数转化为主机字节序整数
uint16_t ntohs(uint16_t netshort);  //将2字节的网络字节序整数转化为主机字节序整数
```
- 字节序转换接口-整数与字符串的转化
`int inet_pton(int af,const char* src,void* dst);`---字符串-整数
af：地址域-说明是哪种地址结构
src：字符串的IP地址
dst：转化后的网络字节序整数的IP地址
`in_addr_t inet_addr(char* ip_str)`---将点分2十进制字符串IP地址转换位网络字节序的整数IP地址
`char* inet_ntoa(struct in_addr sin_addr)`---将网络字节序IP地址转换位字符串IP地址，并返回字符串首地址
`const char* inet_ntop(int af,const void* dst,socklen_t size);`---整数-字符串
af：地址域
src：网络字节序的整数IP地址
dst：缓冲区，接受转化后的字符串IP地址
size：缓冲区长度