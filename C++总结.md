# C++术语解释
1. 对象？
本质：一块能存储数据并具有某种类型的内存空间
情形1：只在类有关的场景中使用
情形2：对于未命名的对象（自定义、类）称作对象；对于已命名的对象（内置类型）称作变量
情形3：将对象与值分开，对象指可修改的数据；值指只读的数据
2. 初始化与赋值
初始化：创建一个变量时赋予其一个初始值
赋值：把对象当前值擦除，用一个新值代替
3. C++是一种静态类型语言，会在编译阶段检查变量类型（类型检查）
4. 允许内层作用域重定义外层作用域已有的名字
4. 指针与引用的主要区别
4.1 类型：指针是一个对象，且不一定要初始化，引用不是对象且必须初始化；
4.2 大小：引用的大小是所指向的变量的大小；指针是指针本身的大小
4.3 功能：指针可以更改指向，引用不可以
4.4 安全：引用比指针更安全，会有空指针、野指针，不会有空引用，野引用
5. 值传递与引用传递
值传递：指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
引用传递：引用传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
6. 变量的定义：一个基本数据类型和一组声明符
由于声明符可以变化，故一条定义语句可定义出不同类型的变量
7. 声明符：类型修饰符、标识符
8. const对象与非const对象可以相互初始化（限制：内置单层类型）
若包括顶层const、底层const则不可交叉初始化。
9. const变量与一般变量的跨文件使用
一般变量使用extern在非定义文件中进行声明则可继续使用，但const变量不行
const变量支持在不同文件中的“重定义”，实际上在各个文件为同名的const变量定义了独立的变量
若想在别的文件中使用同一个const变量，则需要在定义时也加上extern来限制别的文件使用同名const常量时不再次定义
10. 引用
“常量引用”意为：引用的对象为常量，即对const的引用。
在C++中引用被规定，一经初始化，便无法修改所绑定的对象；从这层意思理解，每个引用都为常量，但引用的对象是否是常量由用户自己定义，这并不影响引用本身的性质。
非常量的引用初始值必须为左值。
## 从关键字来总结
- 顶层const：变量本身的const属性；底层const：变量所指对象的const属性。
1. alignas
2. alignof
3. asm
内联汇编_asm块实现
4. auto
auto 一般会忽略顶层const保留底层const.
eg:
```
	int a = 10;
	const int b = 11;
	const int* p1 = &b;
	int* const p2 = &a;
	const int* const p3 = &b;
	auto pp1 = p1;//pp1 -- const int *
	auto pp2 = p2;//pp2 -- int *
	auto pp3 = p3;//pp3 -- const int *
```
5. bool
C++新增类型，只有两个取值，且0为假，1为真
6. break
跳出本循环
7. case
配合switch作为分支使用
8. catch
9. char
基本数据类型，字符类型，`sizeof(char) == 1`
10. char16_t
新增，基本数据类型，无符号双字节，`sizeof(char16_t) == 2`
11. char32_t
新增，基本数据类型，无符号四字节，`sizeof(char32_t) == 4`
12. **class**
类关键词，用于标识一个类类型。实现封装、继承的、多态的主要途径
13. const关键词的使用
- 修饰常量,修饰后该常量的值不会被改变,无论何时(被const_cast脱掉const属性后可以做左值,修改后,值仍然，若加阻止进入寄存器关键字后值也会变化)
常量指针&常量引用const 在*前面 该指针所指向的变量为常量，及对该指针取解引用无法做左值
指针常量&引用常量const 在*后面 该指针为常量，对该指针取解引用可以做左值，但其本身不可更改
常量指针常量&常量引用常量 * 两侧都有const
星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。
14. constexpr
用来验证一个变量是否是常量表达式；改变量只能用常量表达式初始化
在对指针声明时，只针对指针本身（相当于顶层const）
常量表达式：值不会改变，并且在编译过程中就得到计算结果的表达式
字面值类型：算术类型，引用，指针；这些都是常量表达式
15. const_cast
const常量的底层处理：当const常量被初始化后，const常量的值不会发生变化，哪怕该常量的地址上的值被改变，依然无效，const常量的值仍为初始化的值。
给const常量前加上volatile关键字，禁用编译器优化，每次重新去内存里读取，使得地址空间上的值改变。

const类型变量会存入寄存器中，不会再改变，故而改变内存空间地址的值不会改变寄存器的值，变量不发生变化。
而volatile禁止变量存入寄存器，故而改变空间地址的值，会改变const变量的值
16. continue
结束本层循环
17. decltype
类型指示符：从表达式的类型推断出要定义的变量的类型，但不用该表达式的值去初始化变量
```
int i = 42,*p = &i,&r = i;
decltype(r+0) b;//b为未初始化的int型变量
decltype(*p) c;//c为int&型 -- 必须初始化
decltype(r) d;//d为int&型 -- 必须初始化
decltype(i) e;//e为未初始化的int型变量
decltype((i)) f; //d为int&型 -- 必须初始化
```
对于双层括号而言结果永远是引用，单层括号，只有当括号内为引用时或指针解引用时是引用。
传入函数时，不需调用该函数
18. default
快速定义类中的默认成员函数，`a() = default;//使用默认构造`
19. delete
禁用一个成员函数
20. do
`do{}while()`搭配使用
21. double
基本数据类型，双精度浮点数,8字节
22. dynamic_cast
只用于含有虚函数的类，通过虚表来判断子父类指针，且转化会进行安全检测（RTTI），错误时指向0，效率差，安全性高，阻止基类指针转为派生类指针， 若是基类指针由派生类转化而来，则不阻止。
23. else
`if else`搭配使用，从自上而下数到第一个未搭配else的if进行结合。
24. enum
枚举类型`enum {a = 3,b,c,d};//a==3,b == 4,c == 5,d == 6`
25. explicit
在类的构造中使用，防止隐式转换
当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。
26. export
27. extern
28. false
29. float
30. for
31. friend
32. goto
33. if
34. inline
35. int 
36. long
37. mutable
38. namespace
39. new
40. noexcept
41. nullptr
42. operator
43. private
44. protected
45. public
46. register
47. reginterpret_cast
通常为运算对象的位模式提供较低层次上的重新解释
在父子类指针转化的过程中，reinterpre_cast 比之前两个差，只将值拷贝。
48. return
49. short
50. signed
51. sizeof
52. static
53. static_assert
54. static_cast 
静态转化（不可对普通指针进行转化）
任何具有明确定义的类型转换，只要不包含底层const
`static_cast<int>();//内置类型，关键字，类似于模板函数`
可进行父子类指针间的转化，不会进行安全检测，
55. struct
56. switch
57. template
58. this
59. thread_local
60. throw
61. true
62. try
63. typedef
类型别名
`typedef name1 name2`
name2 为name1的别名
64. typeid
66. typename
67. union
68. unsigned
69. using
类型别名
`using name2 = name1`
name2 为name1的别名
70. virtual
71. void
72. volatile
73. wchar_t
74. while

