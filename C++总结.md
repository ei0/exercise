# C++术语解释
1. 对象？
本质：一块能存储数据并具有某种类型的内存空间
情形1：只在类有关的场景中使用
情形2：对于未命名的对象（自定义、类）称作对象；对于已命名的对象（内置类型）称作变量
情形3：将对象与值分开，对象指可修改的数据；值指只读的数据
2. 初始化与赋值
初始化：创建一个变量时赋予其一个初始值
赋值：把对象当前值擦除，用一个新值代替
3. C++是一种静态类型语言，会在编译阶段检查变量类型（类型检查）
4. 允许内层作用域重定义外层作用域已有的名字
4. 指针与引用的主要区别
4.1 类型：指针是一个对象，且不一定要初始化，引用不是对象且必须初始化；
4.2 大小：引用的大小是所指向的变量的大小；指针是指针本身的大小
4.3 功能：指针可以更改指向，引用不可以
4.4 安全：引用比指针更安全，会有空指针、野指针，不会有空引用，野引用
5. 值传递与引用传递
值传递：指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
引用传递：引用传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
6. 变量的定义：一个基本数据类型和一组声明符
由于声明符可以变化，故一条定义语句可定义出不同类型的变量
7. 声明符：类型修饰符、标识符
8. const对象与非const对象可以相互初始化（限制：内置单层类型）
若包括顶层const、底层const则不可交叉初始化。
9. const变量与一般变量的跨文件使用
一般变量使用extern在非定义文件中进行声明则可继续使用，但const变量不行
const变量支持在不同文件中的“重定义”，实际上在各个文件为同名的const变量定义了独立的变量
若想在别的文件中使用同一个const变量，则需要在定义时也加上extern来限制别的文件使用同名const常量时不再次定义
10. 引用
“常量引用”意为：引用的对象为常量，即对const的引用。
在C++中引用被规定，一经初始化，便无法修改所绑定的对象；从这层意思理解，每个引用都为常量，但引用的对象是否是常量由用户自己定义，这并不影响引用本身的性质。
非常量的引用初始值必须为左值。
## 从关键字来总结
- 顶层const：变量本身的const属性；底层const：变量所指对象的const属性。
1. alignas
2. alignof
3. asm
内联汇编_asm块实现
4. auto
auto 一般会忽略顶层const保留底层const.
eg:
```
	int a = 10;
	const int b = 11;
	const int* p1 = &b;
	int* const p2 = &a;
	const int* const p3 = &b;
	auto pp1 = p1;//pp1 -- const int *
	auto pp2 = p2;//pp2 -- int *
	auto pp3 = p3;//pp3 -- const int *
```
5. bool
C++新增类型，只有两个取值，且0为假，1为真
BOOL和bool的区别
一、
1、类型不同
BOOL为int型
bool为布尔型
2、长度不同
bool只有一个字节
BOOL长度视实际环境来定，一般可认为是4个字节
3、取值不同
bool取值false和true，是0和1的区别
BOOL取值FALSE和TRUE，是0和非0的区别
6. break
跳出本循环
7. case
配合switch作为分支使用
8. catch
9. char
基本数据类型，字符类型，`sizeof(char) == 1`
10. char16_t
新增，基本数据类型，无符号双字节，`sizeof(char16_t) == 2`
11. char32_t
新增，基本数据类型，无符号四字节，`sizeof(char32_t) == 4`
12. **class**
类关键词，用于标识一个类类型。实现封装、继承的、多态的主要途径
13. const关键词的使用
- 修饰常量,修饰后该常量的值不会被改变,无论何时(被const_cast脱掉const属性后可以做左值,修改后,值仍然，若加阻止进入寄存器关键字后值也会变化)
常量指针&常量引用const 在*前面 该指针所指向的变量为常量，及对该指针取解引用无法做左值
指针常量&引用常量const 在*后面 该指针为常量，对该指针取解引用可以做左值，但其本身不可更改
常量指针常量&常量引用常量 * 两侧都有const
星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。
14. constexpr
用来验证一个变量是否是常量表达式；改变量只能用常量表达式初始化
在对指针声明时，只针对指针本身（相当于顶层const）
常量表达式：值不会改变，并且在编译过程中就得到计算结果的表达式
字面值类型：算术类型，引用，指针；这些都是常量表达式

用来修饰函数是，若传入的参数可以在编译期间计算处理，那么这个函数就会产生编译时期的值。若不能产生则和普通函数一样。
检测constexpr函数是否产生编译时期的发法，array需要编译器常值才能通过编译。
提高效率
15. const_cast
const常量的底层处理：当const常量被初始化后，const常量的值不会发生变化，哪怕该常量的地址上的值被改变，依然无效，const常量的值仍为初始化的值。
给const常量前加上volatile关键字，禁用编译器优化，每次重新去内存里读取，使得地址空间上的值改变。

const类型变量会存入寄存器中，不会再改变，故而改变内存空间地址的值不会改变寄存器的值，变量不发生变化。
而volatile禁止变量存入寄存器，故而改变空间地址的值，会改变const变量的值
16. continue
结束本层循环
17. decltype
类型指示符：从表达式的类型推断出要定义的变量的类型，但不用该表达式的值去初始化变量
```
int i = 42,*p = &i,&r = i;
decltype(r+0) b;//b为未初始化的int型变量
decltype(*p) c;//c为int&型 -- 必须初始化
decltype(r) d;//d为int&型 -- 必须初始化
decltype(i) e;//e为未初始化的int型变量
decltype((i)) f; //d为int&型 -- 必须初始化
```
对于双层括号而言结果永远是引用，单层括号，只有当括号内为引用时或指针解引用时是引用。
传入函数时，不需调用该函数
18. default
快速定义类中的默认成员函数，`a() = default;//使用默认构造`
19. delete
禁用一个成员函数
20. do
`do{}while()`搭配使用
21. double
基本数据类型，双精度浮点数,8字节
22. dynamic_cast
只用于含有虚函数的类，通过虚表来判断子父类指针，且转化会进行安全检测（RTTI），错误时指向0，效率差，安全性高，阻止基类指针转为派生类指针， 若是基类指针由派生类转化而来，则不阻止。
23. else
`if else`搭配使用，从自上而下数到第一个未搭配else的if进行结合。
24. enum
枚举类型`enum {a = 3,b,c,d};//a==3,b == 4,c == 5,d == 6`
25. explicit
在类的构造中使用，防止隐式转换
当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。
26. export
但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准C++新增加的关键字export（导出/出口/输出）。
C++11后不再支持
27. extern
声明
为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字extern，来使用这些变量或对象时
28. false
FALSE/TRUE是int类型，而false/true是bool类型
29. float
单精度浮点数，4字节，基本数据类型
30. for
传统for:
`for(init;cond;expr)statement`循环执行的顺序init->cond->statement->expr若cond为false则退出循环
for循环的三个头部在语法上均可省略
init中可定义多个同一类型变量，但不可定义不同类型变量
范围for：
`for(declaration:expression)statement`
declaration：定义一个变量，使得expr中的每个元素都能转换为改变量，一般使用auto来保证定义的类型正确
expression：一个待遍历序列，该序列必须支持++，返回迭代器的begin和end成员
31. friend
友元、友元类，友元就是让一个外部函数或者外部类能访问我的私有成员，友元函数会在特定的情况下使用，是普通的函数不属于类的成员。使用friend函数在类里进行声明   
友元关系是单向的，无法传递的。
在用C++实现单例模式时，可以利用友元函数实例化对象。然后把类的构造函数和析构函数都设计成私有函数。
31.1 普通的非成员函数友元---可以引用类中的私有成员
31.2 类作为友元需要注意的是友元类和原始类之间的相互依赖关系
&emsp;如果在友元类中定义的函数使用到了原始类的私有变量，那么就需要在友元类定义的文件中包含原始类定义的头文件。
&emsp;但是在原始类的定义中（包含友元类声明的那个类），就不需要包含友元类的头文件.
&emsp;另外，不需要在类定义前去声明友元类，因为友元类的声明自身就是一种声明
31.3 类成员函数作为友元函数
因为你要类成员函数作为友元，你在声明友元的时候要用类限定符，所以必须先定义包含友元函数的类，但是在定义友元的函数时候，又必须事先定义原始类。
通常的做法先定义包含友元函数的类，再定义原始类，这个顺序不能乱
32. goto
跳转语句，跳转到某一代码块，容易破坏代码的逻辑结构，不建议使用
33. if
判断语句`if(cond)statement else statement`通常与else连用，条件成立进入statement执行且跳过对应的else，不成立进入else
34. inline
内联函数关键词，将函数设为inline后，函数会在调用处展开，而非进入函数栈
35. int 
基本数据类型，有符号整型，vs2019为4字节，大致为正负21亿左右
36. long
基本数据类型，有符号整型，4字节
37. mutable
被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
若数据被mutable修饰，那么它就可以突破const的限制，在被const修饰的函数里面也能被修改。
38. namespace
命名空间，是对全局作用域的细分`namespace name{…… ……}`使用时用双冒号访问该域`name::a`
39. new

c中
`void* malloc(size_t size)//申请size个字节的空间`
`void* calloc(size_t size,size_t size)//将p的值拷贝到新空间去`
`void *realloc(void*p,size_t size)//释放p，返回刚申请的新空间`
通过动态内存分配实例化对象时，new/delete会自动调用构造/析构函数，而malloc。realloc不会调用 
```
	Date *pd = (Date*)malloc(sizeof(Date));//分配空间
	Date *pd = (Date*)operator new(sizeof(Date));//分配空间，抛异常
	Date *pd = new Date(2000, 01, 01);//分配空间，调用构造函数
    eg:Date *pd = new Date[3]{Date(1999,01,01),Date(1998,01,01),Date(1997,01,01)}//数组的空间分配，抛异常与调用构造函数(无参),c++11后支持有参的调用
	delete[] pd;
```
定位new
`eg:Date *pd = new (buffer) Date[2];//buffer为已申请的内存池`
通过定位new申请的空间，实际上它并没有新申请空间，不需要进行delete进行释放，若有需要进行析构，使用显示析构的方法调用。
40. noexcept
用来声明一个函数时，若`void fun() noexcept(ture)`表示该函数不会抛出异常，若`void fun() noexcept(false)`则有可能抛出false的异常
析构函数默认被声明为noexcept，因为析构函数不应该抛出任何异常
41. nullptr
空指针，0更像整型，NULL底部也是0，故而在使用0和空指针时容易造成数据二义，C++11引入nullptr
42. operator
重载操作符
在类内声明时，和普通的成员函数一样，不过将原本的函数名替换为operator加要重载的C++预定义操作符
43. private
不可继承，不可访问---0
私有，可以包含私有成员变量和私有成员函数
类外对象无法访问类的私有成员
在类的成员函数中可以访问同类型实例对象的私有成员变量．
44. protected
可继承，不可访问---1
45. public
可继承，可访问---2
 class继承时默认的继承方式为private；struct默认继承方式为public
 >派生类中继承来的元素是什么权限，取决于继承方式和基类成员权限的较小值
46. register
**建议而非命令**
这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率
46.1. register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
46.2. 因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
46.3. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。
46.4. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。
46.5. 早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时register修饰符是C语言的一种很有价值的补充。然而，随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。
47. reginterpret_cast
通常为运算对象的位模式提供较低层次上的重新解释
在父子类指针转化的过程中，reinterpre_cast 比之前两个差，只将值拷贝。
48. return
结束当前正在执行的函数，并将控制权返回给调用此函数的函数，由该函数的返回值类型，决定return后面跟的是什么
49. short
50. signed
51. sizeof
52. static
53. static_assert
54. static_cast 
静态转化（不可对普通指针进行转化）
任何具有明确定义的类型转换，只要不包含底层const
`static_cast<int>();//内置类型，关键字，类似于模板函数`
可进行父子类指针间的转化，不会进行安全检测，
55. struct
56. switch
57. template
58. this
59. thread_local
60. throw
61. true
FALSE/TRUE是int类型，而false/true是bool类型
62. try
63. typedef
类型别名
`typedef name1 name2`
name2 为name1的别名
64. typeid
66. typename
67. union
68. unsigned
69. using
类型别名
`using name2 = name1`
name2 为name1的别名
70. virtual
71. void
72. volatile
73. wchar_t
74. while

